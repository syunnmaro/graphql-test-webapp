import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: any;
};

/**
 * CreateTodoInput is used for create Todo object.
 * Input was generated by ent.
 */
export type CreateTodoInput = {
  done: Scalars['Boolean'];
  text: Scalars['String'];
  userID: Scalars['ID'];
};

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  name: Scalars['String'];
  todoIDs?: InputMaybe<Array<Scalars['ID']>>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createTodo?: Maybe<Todo>;
};


export type MutationCreateTodoArgs = {
  input: CreateTodoInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Query = {
  __typename?: 'Query';
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  todos: Array<Todo>;
  users: Array<User>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};

export type Todo = Node & {
  __typename?: 'Todo';
  done: Scalars['Boolean'];
  id: Scalars['ID'];
  text: Scalars['String'];
  user: User;
  userID: Scalars['ID'];
};

/**
 * TodoWhereInput is used for filtering Todo objects.
 * Input was generated by ent.
 */
export type TodoWhereInput = {
  and?: InputMaybe<Array<TodoWhereInput>>;
  /** done field predicates */
  done?: InputMaybe<Scalars['Boolean']>;
  doneNEQ?: InputMaybe<Scalars['Boolean']>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idContainsFold?: InputMaybe<Scalars['ID']>;
  idEqualFold?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<TodoWhereInput>;
  or?: InputMaybe<Array<TodoWhereInput>>;
  /** text field predicates */
  text?: InputMaybe<Scalars['String']>;
  textContains?: InputMaybe<Scalars['String']>;
  textContainsFold?: InputMaybe<Scalars['String']>;
  textEqualFold?: InputMaybe<Scalars['String']>;
  textGT?: InputMaybe<Scalars['String']>;
  textGTE?: InputMaybe<Scalars['String']>;
  textHasPrefix?: InputMaybe<Scalars['String']>;
  textHasSuffix?: InputMaybe<Scalars['String']>;
  textIn?: InputMaybe<Array<Scalars['String']>>;
  textLT?: InputMaybe<Scalars['String']>;
  textLTE?: InputMaybe<Scalars['String']>;
  textNEQ?: InputMaybe<Scalars['String']>;
  textNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']>;
  userIDContains?: InputMaybe<Scalars['ID']>;
  userIDContainsFold?: InputMaybe<Scalars['ID']>;
  userIDEqualFold?: InputMaybe<Scalars['ID']>;
  userIDGT?: InputMaybe<Scalars['ID']>;
  userIDGTE?: InputMaybe<Scalars['ID']>;
  userIDHasPrefix?: InputMaybe<Scalars['ID']>;
  userIDHasSuffix?: InputMaybe<Scalars['ID']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']>>;
  userIDLT?: InputMaybe<Scalars['ID']>;
  userIDLTE?: InputMaybe<Scalars['ID']>;
  userIDNEQ?: InputMaybe<Scalars['ID']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateTodoInput is used for update Todo object.
 * Input was generated by ent.
 */
export type UpdateTodoInput = {
  done?: InputMaybe<Scalars['Boolean']>;
  text?: InputMaybe<Scalars['String']>;
  userID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addTodoIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearTodos?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  removeTodoIDs?: InputMaybe<Array<Scalars['ID']>>;
};

export type User = Node & {
  __typename?: 'User';
  id: Scalars['ID'];
  name: Scalars['String'];
  todos?: Maybe<Array<Todo>>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** todos edge predicates */
  hasTodos?: InputMaybe<Scalars['Boolean']>;
  hasTodosWith?: InputMaybe<Array<TodoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idContainsFold?: InputMaybe<Scalars['ID']>;
  idEqualFold?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
};

export type GetTodoQueryVariables = Exact<{ [key: string]: never; }>;


export type GetTodoQuery = { __typename?: 'Query', todos: Array<{ __typename?: 'Todo', id: string, text: string }> };

export type CreateTodoMutationVariables = Exact<{ [key: string]: never; }>;


export type CreateTodoMutation = { __typename?: 'Mutation', createTodo?: { __typename?: 'Todo', id: string, text: string, done: boolean, userID: string } | null };


export const GetTodoDocument = gql`
    query getTodo {
  todos {
    id
    text
  }
}
    `;
export const CreateTodoDocument = gql`
    mutation CreateTodo {
  createTodo(input: {text: "Create GraphQL Example", done: false, userID: 1}) {
    id
    text
    done
    userID
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    getTodo(variables?: GetTodoQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetTodoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetTodoQuery>(GetTodoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getTodo', 'query');
    },
    CreateTodo(variables?: CreateTodoMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<CreateTodoMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateTodoMutation>(CreateTodoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'CreateTodo', 'mutation');
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;